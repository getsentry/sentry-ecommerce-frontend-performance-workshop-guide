---
title: Setting Up Performance & Error Monitoring
description: Instrument Sentry and configure alerts to catch critical issues before they impact your customers
---

import { Steps } from '@astrojs/starlight/components';
import ScaledImage from '../../components/ScaledImage.astro';

The holiday season is approaching. Traffic is about to spike. Let's get Sentry instrumented so you can monitor performance, catch errors, and keep your e-commerce site running smoothly when it matters most.

In this module, you'll instrument **Performance Monitoring, Error Tracking, Session Replay, and Distributed Tracing** across your React frontend and Node.js backend, then set up **alert rules** to surface critical issues fast.

:::note[Before You Begin]
Make sure you have two Sentry projects created:
1. **Frontend Project**: Select "React" as the platform
2. **Backend Project**: Select "Node.js" as the platform

Save both DSN values - you'll need them in the next steps.
:::

## Instrumenting Your Frontend (React)

<Steps>

1. **Install Sentry's React SDK**

   From the root of your `unborked` repository:

   ```bash
   pnpm add @sentry/react --filter web
   ```

2. **Create the instrumentation file**

   Create `apps/web/src/instrument.ts`:

   ```typescript
   import * as Sentry from '@sentry/react';

   Sentry.init({
     dsn: import.meta.env.VITE_SENTRY_DSN,

     integrations: [
       // Capture Web Vitals and browser performance
       Sentry.browserTracingIntegration({
         enableLongTask: true,
         enableInp: true,
       }),

       // Session Replay for debugging user interactions
       Sentry.replayIntegration({
         maskAllText: false,
         maskAllInputs: true,
         blockAllMedia: false,
       }),
     ],

     // Performance Monitoring
     tracesSampleRate: 1.0, // 100% in dev (reduce to 0.1-0.3 in production)

     // Distributed tracing - connect frontend to backend
     tracePropagationTargets: ['localhost:3001', /^https:\/\/your-api\.com/],

     // Session Replay sampling
     replaysSessionSampleRate: 0.1,  // 10% of sessions
     replaysOnErrorSampleRate: 1.0,  // 100% of errors

     sendDefaultPii: true,
     environment: import.meta.env.MODE,
   });
   ```

3. **Import instrumentation in `main.tsx`**

   Add this import at the **very top** of `apps/web/src/main.tsx`:

   ```typescript
   // This MUST be the first import!
   import './instrument';

   import React from 'react';
   import ReactDOM from 'react-dom/client';
   // ... rest of your imports
   ```

   :::caution[Import Order Matters]
   The instrument file must be imported first to capture all errors and performance data from the start.
   :::

4. **Update environment variables**

   Add your Sentry DSN to `apps/web/.env`:

   ```bash
   VITE_SENTRY_DSN=<Your Frontend Sentry DSN>
   VITE_API_BASE_URL=http://localhost:3001
   ```

5. **Set up sourcemaps with Sentry Wizard**

   Sourcemaps help you debug minified production code:

   ```bash
   cd apps/web
   pnpx @sentry/wizard@latest -i sourcemaps
   ```

   Follow the prompts:
   - Select `Sentry SaaS`
   - Choose your organization and frontend project
   - Select `Vite` as the bundler
   - Select `PNPM` as package manager
   - Select `No` for CI/CD

   This creates `.env.sentry-build-plugin` and updates `vite.config.ts` automatically.

</Steps>

{/* TODO: Add screenshot of Sentry dashboard showing transactions coming in */}

## Instrumenting Your Backend (Node.js)

<Steps>

1. **Install Sentry's Node SDK**

   ```bash
   pnpm add @sentry/node --filter api
   ```

2. **Create the instrumentation file**

   Create `apps/api/src/instrument.ts`:

   ```typescript
   import * as Sentry from '@sentry/node';

   Sentry.init({
     dsn: process.env.SENTRY_DSN,

     // Performance Monitoring
     tracesSampleRate: 1.0, // 100% in dev

     // Enable console logs in traces
     enableLogs: true,

     environment: process.env.NODE_ENV || 'development',
   });
   ```

3. **Import instrumentation in `index.ts`**

   At the **very top** of `apps/api/src/index.ts`:

   ```typescript
   // This MUST be the first import!
   import './instrument';

   import express from 'express';
   import * as Sentry from '@sentry/node';
   // ... other imports

   const app = express();

   // ... your middleware and routes ...

   // Add Sentry error handler AFTER all routes
   Sentry.setupExpressErrorHandler(app);

   // Your custom error handler (if any) goes after
   ```

4. **Update environment variables**

   Add to `apps/api/.env`:

   ```bash
   SENTRY_DSN=<Your Backend Sentry DSN>
   DATABASE_URL=postgresql://user:password@localhost:5432/unborked
   ```

5. **Test your setup**

   Start the dev servers:

   ```bash
   cd ../..  # Back to root
   pnpm dev
   ```

   Open [http://localhost:5173](http://localhost:5173) and browse around. You should see transactions flowing into both Sentry projects.

</Steps>

{/* TODO: Add screenshot of Sentry Performance view showing frontend and backend transactions */}

## Connecting Frontend to Backend (Distributed Tracing)

Distributed tracing lets you follow a request from the user's browser, through your frontend, to your backend API, and down to the database. This is crucial for understanding end-to-end performance.

The configuration you added above (`tracePropagationTargets` in frontend) automatically connects frontend and backend traces.

**To verify it's working:**

1. Navigate to a product page in your app
2. In Sentry, find the pageload transaction for that page
3. Click **"View Full Trace"** to see both frontend and backend spans connected

{/* TODO: Add screenshot of a distributed trace showing frontend → backend connection */}

:::tip[What You Should See]
A waterfall view showing your React pageload, the API request, database queries, and total response time. This is your performance debugging superpower.
:::

## Setting Up Alert Rules

Now that data is flowing, let's set up alerts to catch critical issues before your customers notice.

<Steps>

1. **Create an Error Rate Alert (Frontend)**

   Navigate to your frontend project in Sentry → **Alerts** → **Create Alert**

   - **Alert Type**: Issues
   - **Condition**: When the error rate is above 1%
   - **Environment**: Production (or All Environments)
   - **Actions**: Send notification to Email/Slack

   {/* TODO: Add screenshot of error rate alert configuration */}

2. **Create a Web Vitals Alert (LCP)**

   Create another alert for poor LCP performance:

   - **Alert Type**: Metric Alert
   - **Metric**: `p75(measurements.lcp)`
   - **Condition**: Above 2500ms for 5 minutes
   - **Filter**: `transaction.op:pageload`
   - **Actions**: Send notification

   {/* TODO: Add screenshot of LCP alert configuration */}

   :::note[Why LCP?]
   Largest Contentful Paint (LCP) measures how fast your main content loads. Above 2.5s is considered poor. During holiday traffic, this directly impacts conversions.
   :::

3. **Create a Backend Performance Alert**

   Switch to your backend project → **Alerts** → **Create Alert**

   - **Alert Type**: Metric Alert
   - **Metric**: `p95(transaction.duration)`
   - **Condition**: Above 1000ms (1 second)
   - **Actions**: Send notification

   {/* TODO: Add screenshot of backend performance alert */}

</Steps>

## Configuring GitHub Integration (For Seer AI)

Sentry's AI-powered debugging tool, **Seer**, needs access to your code repository to provide context-aware suggestions and even open PRs with fixes. Let's connect GitHub now so we can use it later.

{/* TODO: Add screenshot of GitHub integration page */}

<Steps>

1. **Enable AI features in Sentry**

   Navigate to [Organization Settings](https://sentry.io/orgredirect/organizations/:orgslug/settings/#hideAiFeatures) and ensure AI features are enabled.

2. **Install the GitHub integration**

   - Go to **Organization Settings** → **Integrations** → **GitHub**
   - Click **Install** (or **Upgrade** if you have the legacy integration)
   - Click **Add Installation**
   - Authorize Sentry in the GitHub popup

3. **Select repositories**

   Choose your forked `unborked` repository (or all repositories)

4. **Configure repository access**

   Back in Sentry:
   - Navigate to your GitHub integration
   - Click **Configurations** tab → **Configure**
   - Confirm your repositories are listed (refresh if needed)

</Steps>

{/* TODO: Add screenshot of configured GitHub integration */}

:::tip[What's Next?]
With Sentry instrumented and alerts configured, you're ready to start identifying performance issues. In the next module, we'll dive into Web Vitals optimization and fix real performance problems.
:::

## Verify Your Setup

Before moving on, let's confirm everything is working:

- [ ] Frontend transactions appear in Sentry Performance view
- [ ] Backend transactions appear in Sentry Performance view
- [ ] You can see a connected trace (View Full Trace) from frontend → backend
- [ ] Session Replays are being recorded (check Replays tab in frontend project)
- [ ] Alert rules are created and active
- [ ] GitHub integration is connected

**Having issues?** Check that:
- Environment variables are set correctly in both `.env` files
- `instrument.ts` is imported first in both `main.tsx` and `index.ts`
- Your dev servers are running (`pnpm dev` from root)

---

**Next up:** We'll identify and fix Web Vitals issues like slow LCP, layout shifts, and render-blocking requests that hurt your conversion rates.
